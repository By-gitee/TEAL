# mask_sparsify_to_csc 算子性能对比测试

## 概述

本测试脚本用于对比两种 `mask_sparsify_to_csc` 算子实现的性能：

1. **mask_sparsify_to_csc** - 基础 OpenMP 并行版本（标量写入）
2. **mask_sparsify_to_csc_scatter** - SVE scatter store 优化版本

## 算子说明

### mask_sparsify_to_csc（基础版本）

**实现文件**: `kernels/cpp_sve_sparse_gemm/mask_sparsify_to_csc_op.cpp`

**实现策略**:
- Pass 1: 并行统计每列的非零元素数量（线程局部计数）
- Pass 2: 规约线程局部计数，构建列指针（前缀和）
- Pass 3: 并行填充 CSC 数据结构（row_indices, values）
  - 使用标量写入，每个线程维护独立的写入位置

### mask_sparsify_to_csc_scatter（SVE 优化版本）

**实现文件**: `kernels/cpp_sve_sparse_gemm/mask_sparsify_to_csc_scatter_op.cpp`

**实现策略**:
- Pass 1-2: 与基础版本相同
- Pass 3: 优化的并行写入
  - 当 `total_nnz <= UINT32_MAX` 时，使用 SVE scatter store 指令
  - SVE scatter store 允许向量化写入到非连续的内存位置
  - 每个 SVE 向量通道对应一列，直接 scatter 写入各列桶中
  - 相比标量循环，减少了循环开销，提高了并行度

**关键优化**:
```cpp
// SVE scatter store 写入 row_indices 和 values
svst1_scatter_u32offset_u32(p_keep, out_row, off, v_row);
svst1_scatter_u32offset_f32(p_keep, out_val, off, v);
```

## 使用方法

### 测试预设配置

直接运行脚本，将测试多个预设配置：

```bash
python benchmark_mask_sparsify_to_csc.py
```

预设配置包括：
- 小规模：M=128, K=4096, 稀疏度 0.5/0.7/0.9
- 中等规模：M=256, K=4096, 稀疏度 0.5/0.7/0.9
- 大规模：M=512, K=4096, 稀疏度 0.5/0.7/0.9
- 更大规模：M=1024, K=4096, 稀疏度 0.7/0.9

### 测试自定义配置

指定矩阵大小和稀疏度：

```bash
python benchmark_mask_sparsify_to_csc.py --M 256 --K 4096 --sparsity 0.8
```

### 参数说明

- `--M`: 矩阵行数
- `--K`: 矩阵列数
- `--sparsity`: 稀疏度（0-1，表示零元素比例）
- `--warmup`: 预热次数（默认：5）
- `--iters`: 测试迭代次数（默认：20）

### 调整测试精度

增加预热和迭代次数以获得更准确的测量结果：

```bash
python benchmark_mask_sparsify_to_csc.py --warmup 10 --iters 50
```

## 输出示例

```
================================================================================
测试配置: M=256, K=4096, 稀疏度=70.00%
================================================================================
实际非零元素数: 314,920 / 1,048,576
实际稀疏度: 69.97%

────────────────────────────────────────────────────────────────────────────────
测试 mask_sparsify_to_csc (基础版本)
────────────────────────────────────────────────────────────────────────────────
延迟: 2.456 ms
输出 CSC 格式: nnz=314,920

────────────────────────────────────────────────────────────────────────────────
测试 mask_sparsify_to_csc_scatter (SVE scatter 优化版本)
────────────────────────────────────────────────────────────────────────────────
延迟: 1.823 ms
输出 CSC 格式: nnz=314,920

────────────────────────────────────────────────────────────────────────────────
验证正确性
────────────────────────────────────────────────────────────────────────────────
✓ 结果一致

────────────────────────────────────────────────────────────────────────────────
性能对比
────────────────────────────────────────────────────────────────────────────────
算子                                     延迟 (ms)         加速比    
────────────────────────────────────────────────────────────────────────────────
mask_sparsify_to_csc (基础)                    2.456         1.00x
mask_sparsify_to_csc_scatter (SVE)             1.823         1.35x
────────────────────────────────────────────────────────────────────────────────
✓ SVE scatter 版本提速 34.7%
```

## 性能分析

### 预期性能提升场景

1. **中等到高稀疏度**（50%-90%）
   - 非零元素分散在多列中，scatter store 并行度高
   - 预期加速比：1.2x - 1.5x

2. **较大的 K 值**（列数多）
   - SVE 向量宽度能覆盖更多列，提高向量化效率
   - 预期加速比：1.3x - 1.6x

3. **适中的 M 值**
   - 每列的非零元素数量适中，不会造成过度的 scatter 冲突

### 可能性能下降场景

1. **极低稀疏度**（< 20%）
   - 大量非零元素，scatter 开销可能抵消收益
   - 标量循环可能更高效

2. **极小的矩阵**
   - 向量化开销相对较高
   - 数据量小，内存带宽不是瓶颈

3. **非常不均匀的分布**
   - 如果非零元素集中在少数几列，scatter 并行度降低

## 技术细节

### SVE Scatter Store 优势

1. **向量化写入**: 一次可处理多列（取决于 SVE 向量长度）
2. **减少分支**: 使用 predicate mask 代替条件分支
3. **提高并行度**: 多个写入操作可以并行执行

### 限制条件

1. **total_nnz 必须 <= UINT32_MAX**
   - 当 nnz 过大时，会回退到 int64 标量版本
   - 这是因为 SVE scatter offset 使用 u32

2. **需要 SVE 支持**
   - 在不支持 SVE 的平台上，会回退到标量版本

## 相关文件

- **测试脚本**: `benchmark_mask_sparsify_to_csc.py`
- **Python 包装**: `kernels/sve_sparse_gemm.py`
- **C++ 实现**:
  - 基础版本: `kernels/cpp_sve_sparse_gemm/mask_sparsify_to_csc_op.cpp`
  - SVE 版本: `kernels/cpp_sve_sparse_gemm/mask_sparsify_to_csc_scatter_op.cpp`

## 贡献

如需报告问题或建议改进，请在项目仓库中提交 Issue。
